<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>twisted.protocols.tls.TLSMemoryBIOProtocol : API documentation</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>

    <span style="display: none" id="current-docs-container">
      <em>
        <a id="current-docs-link">
          Go to the latest version of this document.
        </a>
      </em>
    </span>

    <h1 class="class">t.p.t.TLSMemoryBIOProtocol(<a href="twisted.protocols.policies.ProtocolWrapper.html">ProtocolWrapper</a>) : class documentation</h1>
    <p>
      <span id="part">Part of <a href="twisted.html">twisted</a>.<a href="twisted.protocols.html">protocols</a>.<a href="twisted.protocols.tls.html">tls</a></span>
      <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L208">View Source</a>
      <a href="classIndex.html#twisted.protocols.tls.TLSMemoryBIOProtocol">View In Hierarchy</a>
    </p>
    <div>
      <p>Implements interfaces: <a href="twisted.internet.interfaces.ISSLTransport.html">twisted.internet.interfaces.ISSLTransport</a>, <a href="twisted.internet.interfaces.ISystemHandle.html">twisted.internet.interfaces.ISystemHandle</a></p>
    </div>
    <div><a 
href="twisted.protocols.tls.TLSMemoryBIOProtocol.html"><code>TLSMemoryBIOProtocol</code></a>
is a protocol wrapper which uses OpenSSL via a memory BIO to encrypt bytes 
written to it before sending them on to the underlying transport and 
decrypts bytes received from the underlying transport before delivering 
them to the wrapped protocol.</p>
<p>In addition to producer events from the underlying transport, the need 
to wait for reads before a write can proceed means the <a 
href="twisted.protocols.tls.TLSMemoryBIOProtocol.html"><code>TLSMemoryBIOProtocol</code></a>
may also want to pause a producer. Pause/resume events are therefore merged
using the <a 
href="twisted.protocols.tls._ProducerMembrane.html"><code>_ProducerMembrane</code></a>
wrapper. Non-streaming (pull) producers are supported by wrapping them with
<a 
href="twisted.protocols.tls._PullToPush.html"><code>_PullToPush</code></a>.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Instance Variables</td><td class="fieldArg">_tlsConnection</td><td>The <code>OpenSSL.SSL.Connection</code> instance which is encrypted and 
decrypting this connection.
</td></tr><tr><td></td><td class="fieldArg">_lostTLSConnection</td><td>A flag indicating whether connection loss has already been dealt with 
(<code>True</code>) or not (<code>False</code>). TLS disconnection is 
distinct from the underlying connection being lost.
</td></tr><tr><td></td><td class="fieldArg">_writeBlockedOnRead</td><td>A flag indicating whether further writing must wait for data to be received
(<code>True</code>) or not (<code>False</code>).
</td></tr><tr><td></td><td class="fieldArg">_appSendBuffer</td><td>A <code>list</code> of <code>str</code> of application-level (cleartext) 
data which is waiting for <code>_writeBlockedOnRead</code> to be reset to 
<code>False</code> so it can be passed to and perhaps accepted by 
<code>_tlsConnection.send</code>.
</td></tr><tr><td></td><td class="fieldArg">_connectWrapped</td><td>A flag indicating whether or not to call <code>makeConnection</code> on the
wrapped protocol.  This is for the reactor's <a 
href="twisted.internet.interfaces.ITLSTransport.html#startTLS"><code>twisted.internet.interfaces.ITLSTransport.startTLS</code></a>
implementation, since it has a protocol which it has already called 
<code>makeConnection</code> on, and which has no interest in a new 
transport.  See #3821.
</td></tr><tr><td></td><td class="fieldArg">_handshakeDone</td><td>A flag indicating whether or not the handshake is known to have completed 
successfully (<code>True</code>) or not (<code>False</code>).  This is used
to control error reporting behavior.  If the handshake has not completed, 
the underlying <code>OpenSSL.SSL.Error</code> will be passed to the 
application's <code>connectionLost</code> method.  If it has completed, any
unexpected <code>OpenSSL.SSL.Error</code> will be turned into a <a 
href="twisted.protocols.ftp.ConnectionLost.html"><code>ConnectionLost</code></a>.
This is weird; however, it is simply an attempt at a faithful 
re-implementation of the behavior provided by <a 
href="twisted.internet.ssl.html"><code>twisted.internet.ssl</code></a>.
</td></tr><tr><td></td><td class="fieldArg">_reason</td><td>If an unexpected <code>OpenSSL.SSL.Error</code> occurs which causes the 
connection to be lost, it is saved here.  If appropriate, this may be used 
as the reason passed to the application protocol's 
<code>connectionLost</code> method.
</td></tr><tr><td></td><td class="fieldArg">_producer</td><td>The current producer registered via <code>registerProducer</code>, or 
<code>None</code> if no producer has been registered or a previous one was 
unregistered.
</td></tr></table></div>

    
    
    <div id="splitTables">
      <table class="children sortable" id="id1545">
  
  
<tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#__init__">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#getHandle">getHandle</a></td>
    <td><span>Return the <code>OpenSSL.SSL.Connection</code> object being used to 
encrypt and decrypt this connection.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#makeConnection">makeConnection</a></td>
    <td><span>Connect this wrapper to the given transport and initialize the necessary
<code>OpenSSL.SSL.Connection</code> with a memory BIO.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#dataReceived">dataReceived</a></td>
    <td><span>Deliver any received bytes to the receive BIO and then read and deliver 
to the application any application-level data which becomes available as a 
result of this.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#connectionLost">connectionLost</a></td>
    <td><span>Handle the possible repetition of calls to this method (due to either 
the underlying transport going away or due to an error at the TLS layer) 
and make sure the base implementation only gets invoked once.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#loseConnection">loseConnection</a></td>
    <td><span>Send a TLS close alert and close the underlying connection.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#write">write</a></td>
    <td><span>Process the given application bytes and send any resulting TLS traffic 
which arrives in the send BIO.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#writeSequence">writeSequence</a></td>
    <td><span>Write a sequence of application bytes by joining them into one string 
and passing them to <a 
href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#write"><code>write</code></a>.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#getPeerCertificate">getPeerCertificate</a></td>
    <td><span>Return an object with the peer's certificate info.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#registerProducer">registerProducer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#unregisterProducer">unregisterProducer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#_flushSendBIO">_flushSendBIO</a></td>
    <td><span>Read any bytes out of the send BIO and write them to the underlying 
transport.</span></td>
  </tr><tr class="method private">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#_flushReceiveBIO">_flushReceiveBIO</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method private">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#_shutdownTLS">_shutdownTLS</a></td>
    <td><span>Initiate, or reply to, the shutdown handshake of the TLS layer.</span></td>
  </tr><tr class="method private">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#_tlsShutdownFinished">_tlsShutdownFinished</a></td>
    <td><span>Called when TLS connection has gone away; tell underlying transport to 
disconnect.</span></td>
  </tr><tr class="method private">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#_write">_write</a></td>
    <td><span>Process the given application bytes and send any resulting TLS traffic 
which arrives in the send BIO.</span></td>
  </tr>
  
</table>
      
        <p>
          Inherited from <a href="twisted.protocols.policies.ProtocolWrapper.html">ProtocolWrapper</a>:
        </p>
        <table class="children sortable" id="id1546">
  
  
<tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.policies.ProtocolWrapper.html#logPrefix">logPrefix</a></td>
    <td><span>Use a customized log prefix mentioning both the wrapped protocol and the
current one.</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.policies.ProtocolWrapper.html#getPeer">getPeer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.policies.ProtocolWrapper.html#getHost">getHost</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.policies.ProtocolWrapper.html#stopConsuming">stopConsuming</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.protocols.policies.ProtocolWrapper.html#__getattr__">__getattr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
  
</table>
      
        <p>
          Inherited from <a href="twisted.internet.protocol.BaseProtocol.html">BaseProtocol</a> (via <a href="twisted.protocols.policies.ProtocolWrapper.html">ProtocolWrapper</a>, <a href="twisted.internet.protocol.Protocol.html">Protocol</a>):
        </p>
        <table class="children sortable" id="id1547">
  
  
<tr class="basemethod">
    
    
    <td>Method</td>
    <td><a href="twisted.internet.protocol.BaseProtocol.html#connectionMade">connectionMade</a></td>
    <td><span>Called when a connection is made.</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    

    <div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, factory, wrappedProtocol, _connectWrapped=True):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L270" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#__init__">twisted.protocols.policies.ProtocolWrapper.__init__</a></div>
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.getHandle">
    
  </a>
  <a name="getHandle">
    
  </a>
  <div class="functionHeader">
    
    def
    getHandle(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L275" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">from <a href="twisted.internet.interfaces.ISystemHandle.html#getHandle">twisted.internet.interfaces.ISystemHandle</a></div>
    <div>Return the <code>OpenSSL.SSL.Connection</code> object being used to 
encrypt and decrypt this connection.</p>
<p>This is done for the benefit of <a 
href="twisted.internet.ssl.Certificate.html"><code>twisted.internet.ssl.Certificate</code></a>'s
<code>peerFromTransport</code> and <code>hostFromTransport</code> methods 
only.  A different system handle may be returned by future versions of this
method.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.makeConnection">
    
  </a>
  <a name="makeConnection">
    
  </a>
  <div class="functionHeader">
    
    def
    makeConnection(self, transport):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L288" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">from <a href="twisted.internet.interfaces.IProtocol.html#makeConnection">twisted.internet.interfaces.IProtocol</a></div><div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#makeConnection">twisted.protocols.policies.ProtocolWrapper.makeConnection</a></div>
    <div>Connect this wrapper to the given transport and initialize the necessary
<code>OpenSSL.SSL.Connection</code> with a memory BIO.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol._flushSendBIO">
    
  </a>
  <a name="_flushSendBIO">
    
  </a>
  <div class="functionHeader">
    
    def
    _flushSendBIO(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L324" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Read any bytes out of the send BIO and write them to the underlying 
transport.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol._flushReceiveBIO">
    
  </a>
  <a name="_flushReceiveBIO">
    
  </a>
  <div class="functionHeader">
    
    def
    _flushReceiveBIO(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L338" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Try to receive any application-level bytes which are now available 
because of a previous write into the receive BIO.  This will take care of 
delivering any application-level bytes which are received to the protocol, 
as well as handling of the various exceptions which can come from trying to
get such bytes.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.dataReceived">
    
  </a>
  <a name="dataReceived">
    
  </a>
  <div class="functionHeader">
    
    def
    dataReceived(self, bytes):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L391" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">from <a href="twisted.internet.interfaces.IProtocol.html#dataReceived">twisted.internet.interfaces.IProtocol</a></div><div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#dataReceived">twisted.protocols.policies.ProtocolWrapper.dataReceived</a></div>
    <div>Deliver any received bytes to the receive BIO and then read and deliver 
to the application any application-level data which becomes available as a 
result of this.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol._shutdownTLS">
    
  </a>
  <a name="_shutdownTLS">
    
  </a>
  <div class="functionHeader">
    
    def
    _shutdownTLS(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L416" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Initiate, or reply to, the shutdown handshake of the TLS layer.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol._tlsShutdownFinished">
    
  </a>
  <a name="_tlsShutdownFinished">
    
  </a>
  <div class="functionHeader">
    
    def
    _tlsShutdownFinished(self, reason):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L430" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Called when TLS connection has gone away; tell underlying transport to 
disconnect.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.connectionLost">
    
  </a>
  <a name="connectionLost">
    
  </a>
  <div class="functionHeader">
    
    def
    connectionLost(self, reason):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L446" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">from <a href="twisted.internet.interfaces.IProtocol.html#connectionLost">twisted.internet.interfaces.IProtocol</a></div><div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#connectionLost">twisted.protocols.policies.ProtocolWrapper.connectionLost</a></div>
    <div>Handle the possible repetition of calls to this method (due to either 
the underlying transport going away or due to an error at the TLS layer) 
and make sure the base implementation only gets invoked once.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.loseConnection">
    
  </a>
  <a name="loseConnection">
    
  </a>
  <div class="functionHeader">
    
    def
    loseConnection(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L463" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#loseConnection">twisted.protocols.policies.ProtocolWrapper.loseConnection</a></div>
    <div>Send a TLS close alert and close the underlying connection.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.write">
    
  </a>
  <a name="write">
    
  </a>
  <div class="functionHeader">
    
    def
    write(self, bytes):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L474" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#write">twisted.protocols.policies.ProtocolWrapper.write</a></div>
    <div>Process the given application bytes and send any resulting TLS traffic 
which arrives in the send BIO.</p>
<p>If <code>loseConnection</code> was called, subsequent calls to 
<code>write</code> will drop the bytes on the floor.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol._write">
    
  </a>
  <a name="_write">
    
  </a>
  <div class="functionHeader">
    
    def
    _write(self, bytes):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L490" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Process the given application bytes and send any resulting TLS traffic 
which arrives in the send BIO.</p>
<p>This may be called by <code>dataReceived</code> with bytes that were 
buffered before <code>loseConnection</code> was called, which is why this 
function doesn't check for disconnection but accepts the bytes 
regardless.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.writeSequence">
    
  </a>
  <a name="writeSequence">
    
  </a>
  <div class="functionHeader">
    
    def
    writeSequence(self, iovec):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L528" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#writeSequence">twisted.protocols.policies.ProtocolWrapper.writeSequence</a></div>
    <div>Write a sequence of application bytes by joining them into one string 
and passing them to <a 
href="twisted.protocols.tls.TLSMemoryBIOProtocol.html#write"><code>write</code></a>.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.getPeerCertificate">
    
  </a>
  <a name="getPeerCertificate">
    
  </a>
  <div class="functionHeader">
    
    def
    getPeerCertificate(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L536" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">from <a href="twisted.internet.interfaces.ISSLTransport.html#getPeerCertificate">twisted.internet.interfaces.ISSLTransport</a></div>
    <div>Return an object with the peer's certificate info.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.registerProducer">
    
  </a>
  <a name="registerProducer">
    
  </a>
  <div class="functionHeader">
    
    def
    registerProducer(self, producer, streaming):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L540" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#registerProducer">twisted.protocols.policies.ProtocolWrapper.registerProducer</a></div>
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.tls.TLSMemoryBIOProtocol.unregisterProducer">
    
  </a>
  <a name="unregisterProducer">
    
  </a>
  <div class="functionHeader">
    
    def
    unregisterProducer(self):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.1.0/twisted/protocols/tls.py#L555" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="twisted.protocols.policies.ProtocolWrapper.html#unregisterProducer">twisted.protocols.policies.ProtocolWrapper.unregisterProducer</a></div>
    <div class="undocumented">Undocumented</div>
  </div>
</div>
    <address>
      <a href="index.html">API Documentation</a> for <a href="http://twistedmatrix.com/">Twisted</a>, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2011-11-17 13:59:56.
    </address>

    <!-- Google analytics, obviously. -->
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
    <script type="text/javascript">
      _uacct = "UA-99018-6";
      urchinTracker();
    </script>

    <!-- If the documentation isn't current, insert a current link. -->
    <script type="text/javascript">
      if (window.location.pathname.indexOf('/current/') == -1) {
          <!-- Give the user a link to this page, but in the current version of the docs. -->
          var link = document.getElementById('current-docs-link');
          link.href = window.location.pathname.replace(/\/\d+\.\d+\.\d+\/api\//, '/current/api/');
          <!-- And make it visible -->
          var container = document.getElementById('current-docs-container');
          container.style.display = "";
          delete link;
          delete container;
      }
    </script>

  </body>
</html>