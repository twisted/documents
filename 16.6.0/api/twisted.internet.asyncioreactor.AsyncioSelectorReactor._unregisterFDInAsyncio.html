<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>twisted.internet.asyncioreactor.AsyncioSelectorReactor._unregisterFDInAsyncio : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link type="text/css" href="bootstrap.min.css" rel="stylesheet" />
    <link type="text/css" href="apidocs.css" rel="stylesheet" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="navbar-brand">
            Twisted API Documentation
          </a>
        </div>
      </div>
    </nav>

   <div id="current-docs-container" class="container" style="display: none">
      <div class="col-sm-12">
        <a id="current-docs-link">
          Go to the latest version of this document.
        </a>
      </div>
    </div>

    <div id="showPrivate">
      <button onclick="togglePrivate()" class="btn btn-link">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="method private"><code>twisted.internet.asyncioreactor.AsyncioSelectorReactor._unregisterFDInAsyncio(self, fd)</code> <small>method documentation</small></h1>

        <span id="partOf">
          Part of <code><a href="twisted.html" data-type="Package" class="code">twisted</a>.<a href="twisted.internet.html" data-type="Package" class="code">internet</a>.<a href="twisted.internet.asyncioreactor.html" data-type="Module" class="code">asyncioreactor</a>.<a href="twisted.internet.asyncioreactor.AsyncioSelectorReactor.html" data-type="Class" class="code">AsyncioSelectorReactor</a></code>
          <a href="https://github.com/twisted/twisted/tree/twisted-16.6.0/src/twisted/internet/asyncioreactor.py#L72">View Source</a>
          
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      

      <div class="moduleDocstring">
        <div><p>Compensate for a bug in asyncio where it will not unregister a FD that 
it cannot handle in the epoll loop. It touches internal asyncio code.</p>
<p>A description of the bug by markrwilliams:</p>
<p>The <code>add_writer</code> method of asyncio event loops isn't atomic 
because all the Selector classes in the selector module internally record a
file object before passing it to the platform's selector implementation. If
the platform's selector decides the file object isn't acceptable, the 
resulting exception doesn't cause the Selector to un-track the file 
object.</p>
<p>The failing/hanging stdio test goes through the following sequence of 
events (roughly):</p>
<p>* The first <code>connection.write(intToByte(value))</code> call hits 
the asyncio reactor's <code>addWriter</code> method.</p>
<p>* <code>addWriter</code> calls the asyncio loop's 
<code>add_writer</code> method, which happens to live on 
<code>_BaseSelectorEventLoop</code>.</p>
<p>* The asyncio loop's <code>add_writer</code> method checks if the file 
object has been registered before via the selector's <code>get_key</code> 
method.</p>
<p>* It hasn't, so the KeyError block runs and calls the selector's 
register method</p>
<p>* Code examples that follow use EpollSelector, but the code flow holds 
true for any other selector implementation. The selector's register method 
first calls through to the next register method in the MRO</p>
<p>* That next method is always <code>_BaseSelectorImpl.register</code> 
which creates a <code>SelectorKey</code> instance for the file object, 
stores it under the file object's file descriptor, and then returns it.</p>
<p>* Control returns to the concrete selector implementation, which asks 
the operating system to track the file descriptor using the right API.</p>
<p>* The operating system refuses! An exception is raised that, in this 
case, the asyncio reactor handles by creating a 
<code>_ContinuousPolling</code> object to watch the file descriptor.</p>
<p>* The second <code>connection.write(intToByte(value))</code> call hits 
the asyncio reactor's <code>addWriter</code> method, which hits the 
<code>add_writer</code> method. But the loop's selector's get_key method 
now returns a <code>SelectorKey</code>! Now the asyncio reactor's 
<code>addWriter</code> method thinks the asyncio loop will watch the file 
descriptor, even though it won't.</p><table class="fieldTable"></table></div>
      </div>

      <div id="splitTables">
        
        

          
      </div>

      <div id="childList">

        

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="http://twistedmatrix.com/">Twisted</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2016-11-26 06:44:29.
      </address>

    </div>

    <script type="text/javascript" src="pydoctor.js"></script>

    <!-- Google analytics, obviously. -->
    <script type="text/javascript" src="//www.google-analytics.com/urchin.js"></script>
    <script type="text/javascript">
      _uacct = "UA-99018-6";
      urchinTracker();
    </script>

    <!-- If the documentation isn't current, insert a current link. -->
    <script type="text/javascript">
      if (window.location.pathname.indexOf('/current/') == -1) {
        <!-- Give the user a link to this page, but in the current version of the docs. -->
        var link = document.getElementById('current-docs-link');
        link.href = window.location.pathname.replace(/\/\d+\.\d+\.\d+\/api\//, '/current/api/');
        <!-- And make it visible -->
        var container = document.getElementById('current-docs-container');
        container.style.display = "";
        delete link;
        delete container;
      }
    </script>

  </body>
</html>