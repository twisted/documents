<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>twisted.protocols.amp : API documentation</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="module">t.p.amp : module documentation</h1>
    <p>
      <span id="part">Part of <a href="twisted.html">twisted</a>.<a href="twisted.protocols.html">protocols</a></span>
      <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.0.0/twisted/protocols/amp.py">View Source</a>
      
    </p>
    <div>
      
    </div>
    <div><p>This module implements AMP, the Asynchronous Messaging Protocol.</p>
<p>AMP is a protocol for sending multiple asynchronous request/response 
pairs over the same connection.  Requests and responses are both 
collections of key/value pairs.</p>
<p>AMP is a very simple protocol which is not an application.  This module 
is a &quot;protocol construction kit&quot; of sorts; it attempts to be the 
simplest wire-level implementation of Deferreds.  AMP provides the 
following base-level features:</p>
<ul>
  <li>
    Asynchronous request/response handling (hence the name)
  </li>
  <li>
    Requests and responses are both key/value pairs
  </li>
  <li>
    Binary transfer of all data: all data is length-prefixed.  Your 
    application will never need to worry about quoting.
  </li>
  <li>
    Command dispatching (like HTTP Verbs): the protocol is extensible, and 
    multiple AMP sub-protocols can be grouped together easily.
  </li>
</ul>
<p>The protocol implementation also provides a few additional features 
which are not part of the core wire protocol, but are nevertheless very 
useful:</p>
<ul>
  <li>
    Tight TLS integration, with an included StartTLS command.
  </li>
  <li>
    Handshaking to other protocols: because AMP has well-defined message 
    boundaries and maintains all incoming and outgoing requests for you, 
    you can start a connection over AMP and then switch to another 
    protocol. This makes it ideal for firewall-traversal applications where
    you may have only one forwarded port but multiple applications that 
    want to use it.
  </li>
</ul>
<p>Using AMP with Twisted is simple.  Each message is a command, with a 
response. You begin by defining a command type.  Commands specify their 
input and output in terms of the types that they expect to see in the 
request and response key-value pairs.  Here's an example of a command that 
adds two integers, 'a' and 'b':</p>
<pre class="literalblock">
   class Sum(amp.Command):
       arguments = [('a', amp.Integer()),
                    ('b', amp.Integer())]
       response = [('total', amp.Integer())]
</pre>
<p>Once you have specified a command, you need to make it part of a 
protocol, and define a responder for it.  Here's a 'JustSum' protocol that 
includes a responder for our 'Sum' command:</p>
<pre class="literalblock">
   class JustSum(amp.AMP):
       def sum(self, a, b):
           total = a + b
           print 'Did a sum: %d + %d = %d' % (a, b, total)
           return {'total': total}
       Sum.responder(sum)
</pre>
<p>Later, when you want to actually do a sum, the following expression will
return a <a 
href="twisted.internet.defer.Deferred.html"><code>Deferred</code></a> which
will fire with the result:</p>
<pre class="literalblock">
   ClientCreator(reactor, amp.AMP).connectTCP(...).addCallback(
       lambda p: p.callRemote(Sum, a=13, b=81)).addCallback(
           lambda result: result['total'])
</pre>
<p>Command responders may also return Deferreds, causing the response to be
sent only once the Deferred fires:</p>
<pre class="literalblock">
   class DelayedSum(amp.AMP):
       def slowSum(self, a, b):
           total = a + b
           result = defer.Deferred()
           reactor.callLater(3, result.callback, {'total': total})
           return result
       Sum.responder(slowSum)
</pre>
<p>This is transparent to the caller.</p>
<p>You can also define the propagation of specific errors in AMP.  For 
example, for the slightly more complicated case of division, we might have 
to deal with division by zero:</p>
<pre class="literalblock">
   class Divide(amp.Command):
       arguments = [('numerator', amp.Integer()),
                    ('denominator', amp.Integer())]
       response = [('result', amp.Float())]
       errors = {ZeroDivisionError: 'ZERO_DIVISION'}
</pre>
<p>The 'errors' mapping here tells AMP that if a responder to Divide emits 
a <code>ZeroDivisionError</code>, then the other side should be informed 
that an error of the type 'ZERO_DIVISION' has occurred.  Writing a 
responder which takes advantage of this is very simple - just raise your 
exception normally:</p>
<pre class="literalblock">
   class JustDivide(amp.AMP):
       def divide(self, numerator, denominator):
           result = numerator / denominator
           print 'Divided: %d / %d = %d' % (numerator, denominator, total)
           return {'result': result}
       Divide.responder(divide)
</pre>
<p>On the client side, the errors mapping will be used to determine what 
the 'ZERO_DIVISION' error means, and translated into an asynchronous 
exception, which can be handled normally as any <a 
href="twisted.internet.defer.Deferred.html"><code>Deferred</code></a> would
be:</p>
<pre class="literalblock">
   def trapZero(result):
       result.trap(ZeroDivisionError)
       print &quot;Divided by zero: returning INF&quot;
       return 1e1000
   ClientCreator(reactor, amp.AMP).connectTCP(...).addCallback(
       lambda p: p.callRemote(Divide, numerator=1234,
                              denominator=0)
       ).addErrback(trapZero)
</pre>
<p>For a complete, runnable example of both of these commands, see the 
files in the Twisted repository:</p>
<pre class="literalblock">
   doc/core/examples/ampserver.py
   doc/core/examples/ampclient.py
</pre>
<p>On the wire, AMP is a protocol which uses 2-byte lengths to prefix keys 
and values, and empty keys to separate messages:</p>
<pre class="literalblock">
   &lt;2-byte length&gt;&lt;key&gt;&lt;2-byte length&gt;&lt;value&gt;
   &lt;2-byte length&gt;&lt;key&gt;&lt;2-byte length&gt;&lt;value&gt;
   ...
   &lt;2-byte length&gt;&lt;key&gt;&lt;2-byte length&gt;&lt;value&gt;
   &lt;NUL&gt;&lt;NUL&gt;                  # Empty Key == End of Message
</pre>
<p>And so on.  Because it's tedious to refer to lengths and NULs 
constantly, the documentation will refer to packets as if they were newline
delimited, like so:</p>
<pre class="literalblock">
   C: _command: sum
   C: _ask: ef639e5c892ccb54
   C: a: 13
   C: b: 81

   S: _answer: ef639e5c892ccb54
   S: total: 94
</pre>
<p>Notes:</p>
<p>In general, the order of keys is arbitrary.  Specific uses of AMP may 
impose an ordering requirement, but unless this is specified explicitly, 
any ordering may be generated and any ordering must be accepted.  This 
applies to the command-related keys <i>_command</i> and <i>_ask</i> as well
as any other keys.</p>
<p>Values are limited to the maximum encodable size in a 16-bit length, 
65535 bytes.</p>
<p>Keys are limited to the maximum encodable size in a 8-bit length, 255 
bytes. Note that we still use 2-byte lengths to encode keys.  This small 
redundancy has several features:</p>
<ul>
  <li>
    If an implementation becomes confused and starts emitting corrupt data,
    or gets keys confused with values, many common errors will be signalled
    immediately instead of delivering obviously corrupt packets.
  </li>
  <li>
    A single NUL will separate every key, and a double NUL separates 
    messages.  This provides some redundancy when debugging traffic dumps.
  </li>
  <li>
    NULs will be present at regular intervals along the protocol, providing
    some padding for otherwise braindead C implementations of the protocol,
    so that &lt;stdio.h&gt; string functions will see the NUL and stop.
  </li>
  <li>
    This makes it possible to run an AMP server on a port also used by a 
    plain-text protocol, and easily distinguish between non-AMP clients 
    (like web browsers) which issue non-NUL as the first byte, and AMP 
    clients, which always issue NUL as the first byte.
  </li>
</ul>
<table class="fieldTable"></table></div>

    
    
    <div id="splitTables">
      <table class="children sortable" id="id2749">
  
  
<tr class="interface">
    
    
    <td>Interface</td>
    <td><a href="twisted.protocols.amp.IArgumentType.html">IArgumentType</a></td>
    <td><span>An <a 
href="twisted.protocols.amp.IArgumentType.html"><code>IArgumentType</code></a>
can serialize a Python object into an AMP box and</span></td>
  </tr><tr class="interface">
    
    
    <td>Interface</td>
    <td><a href="twisted.protocols.amp.IBoxSender.html">IBoxSender</a></td>
    <td><span>A transport which can send <a 
href="twisted.protocols.amp.AmpBox.html"><code>AmpBox</code></a> 
objects.</span></td>
  </tr><tr class="interface">
    
    
    <td>Interface</td>
    <td><a href="twisted.protocols.amp.IBoxReceiver.html">IBoxReceiver</a></td>
    <td><span>An application object which can receive <a 
href="twisted.protocols.amp.AmpBox.html"><code>AmpBox</code></a> objects 
and dispatch them</span></td>
  </tr><tr class="interface">
    
    
    <td>Interface</td>
    <td><a href="twisted.protocols.amp.IResponderLocator.html">IResponderLocator</a></td>
    <td><span>An application object which can look up appropriate responder methods 
for</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.AmpError.html">AmpError</a></td>
    <td><span>Base class of all Amp-related exceptions.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.ProtocolSwitched.html">ProtocolSwitched</a></td>
    <td><span>Connections which have been switched to other protocols can no 
longer</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.OnlyOneTLS.html">OnlyOneTLS</a></td>
    <td><span>This is an implementation limitation; TLS may only be started once 
per</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.NoEmptyBoxes.html">NoEmptyBoxes</a></td>
    <td><span>You can't have empty boxes on the connection.  This is raised when 
you</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.InvalidSignature.html">InvalidSignature</a></td>
    <td><span>You didn't pass all the required arguments.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.TooLong.html">TooLong</a></td>
    <td><span>One of the protocol's length limitations was violated.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.BadLocalReturn.html">BadLocalReturn</a></td>
    <td><span>A bad value was returned from a local command; we were unable to coerce 
it.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.RemoteAmpError.html">RemoteAmpError</a></td>
    <td><span>This error indicates that something went wrong on the remote end of 
the</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.UnknownRemoteError.html">UnknownRemoteError</a></td>
    <td><span>This means that an error whose type we can't identify was raised from 
the</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.MalformedAmpBox.html">MalformedAmpBox</a></td>
    <td><span>This error indicates that the wire-level protocol was malformed.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.UnhandledCommand.html">UnhandledCommand</a></td>
    <td><span>A command received via amp could not be dispatched.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.IncompatibleVersions.html">IncompatibleVersions</a></td>
    <td><span>It was impossible to negotiate a compatible version of the protocol 
with</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.AmpBox.html">AmpBox</a></td>
    <td><span>I am a packet in the AMP protocol, much like a regular str:str 
dictionary.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.QuitBox.html">QuitBox</a></td>
    <td><span>I am an AmpBox that, upon being sent, terminates the connection.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.BoxDispatcher.html">BoxDispatcher</a></td>
    <td><span>A <a 
href="twisted.protocols.amp.BoxDispatcher.html"><code>BoxDispatcher</code></a>
dispatches '_ask', '_answer', and '_error' <a 
href="twisted.protocols.amp.AmpBox.html"><code>AmpBox</code></a>es,</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.CommandLocator.html">CommandLocator</a></td>
    <td><span>A <a 
href="twisted.protocols.amp.CommandLocator.html"><code>CommandLocator</code></a>
is a collection of responders to AMP <a 
href="twisted.protocols.amp.Command.html"><code>Command</code></a>s, 
with</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.SimpleStringLocator.html">SimpleStringLocator</a></td>
    <td><span>Implement the <a 
href="twisted.protocols.amp.SimpleStringLocator.html#locateResponder"><code>locateResponder</code></a>
method to do simple, string-based</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Argument.html">Argument</a></td>
    <td><span>Base-class of all objects that take values from Amp packets and 
convert</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Integer.html">Integer</a></td>
    <td><span>Encode any integer values of any size on the wire as the string</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.String.html">String</a></td>
    <td><span>Don't do any conversion at all; just pass through 'str'.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Float.html">Float</a></td>
    <td><span>Encode floating-point values on the wire as their repr.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Boolean.html">Boolean</a></td>
    <td><span>Encode True or False as &quot;True&quot; or &quot;False&quot; on the 
wire.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Unicode.html">Unicode</a></td>
    <td><span>Encode a unicode string on the wire as UTF-8.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Path.html">Path</a></td>
    <td><span>Encode and decode <a 
href="twisted.python.filepath.FilePath.html"><code>filepath.FilePath</code></a>
instances as paths on the wire.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.ListOf.html">ListOf</a></td>
    <td><span>Encode and decode lists of instances of a single other argument 
type.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.AmpList.html">AmpList</a></td>
    <td><span>Convert a list of dictionaries into a list of AMP boxes on the wire.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Command.html">Command</a></td>
    <td><span>Subclass me to specify an AMP Command.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.StartTLS.html">StartTLS</a></td>
    <td><span>Use, or subclass, me to implement a command that starts TLS.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.ProtocolSwitchCommand.html">ProtocolSwitchCommand</a></td>
    <td><span>Use this command to switch from something Amp-derived to a different</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.BinaryBoxProtocol.html">BinaryBoxProtocol</a></td>
    <td><span>A protocol for receving <code>Box</code>es - key/value pairs - via 
length-prefixed</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.AMP.html">AMP</a></td>
    <td><span>This protocol is an AMP connection.  See the module docstring for 
protocol</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.Decimal.html">Decimal</a></td>
    <td><span>Encodes <code>decimal.Decimal</code> instances.</span></td>
  </tr><tr class="class">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp.DateTime.html">DateTime</a></td>
    <td><span>Encodes <code>datetime.datetime</code> instances.</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._SwitchBox.html">_SwitchBox</a></td>
    <td><span>Implementation detail of ProtocolSwitchCommand: I am a AmpBox which 
sets</span></td>
  </tr><tr class="function private">
    
    
    <td>Function</td>
    <td><a href="twisted.protocols.amp.html#_wireNameToPythonIdentifier">_wireNameToPythonIdentifier</a></td>
    <td><span>(Private) Normalize an argument name from the wire for use with 
Python</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._NoCertificate.html">_NoCertificate</a></td>
    <td><span>This is for peers which don't want to use a local certificate.  Used 
by</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._TLSBox.html">_TLSBox</a></td>
    <td><span>I am an AmpBox that, upon being sent, initiates a TLS connection.</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._LocalArgument.html">_LocalArgument</a></td>
    <td><span>Local arguments are never actually relayed across the wire.  This is 
just a</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._ParserHelper.html">_ParserHelper</a></td>
    <td><span>A box receiver which records all boxes received.</span></td>
  </tr><tr class="function private">
    
    
    <td>Function</td>
    <td><a href="twisted.protocols.amp.html#_stringsToObjects">_stringsToObjects</a></td>
    <td><span>Convert an AmpBox to a dictionary of python objects, converting through 
a</span></td>
  </tr><tr class="function private">
    
    
    <td>Function</td>
    <td><a href="twisted.protocols.amp.html#_objectsToStrings">_objectsToStrings</a></td>
    <td><span>Convert a dictionary of python objects to an AmpBox, converting through 
a</span></td>
  </tr><tr class="class private">
    
    
    <td>Class</td>
    <td><a href="twisted.protocols.amp._FixedOffsetTZInfo.html">_FixedOffsetTZInfo</a></td>
    <td><span>Represents a fixed timezone offset (without daylight saving time).</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    

    <div class="function">
  <a name="twisted.protocols.amp._wireNameToPythonIdentifier">
    
  </a>
  <a name="_wireNameToPythonIdentifier">
    
  </a>
  <div class="functionHeader">
    
    def
    _wireNameToPythonIdentifier(key):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.0.0/twisted/protocols/amp.py#L1108" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>(Private) Normalize an argument name from the wire for use with Python 
code.  If the return value is going to be a python keyword it will be 
capitalized.  If it contains any dashes they will be replaced with 
underscores.</p>
<p>The rationale behind this method is that AMP should be an inherently 
multi-language protocol, so message keys may contain all manner of bizarre 
bytes.  This is not a complete solution; there are still forms of arguments
that this implementation will be unable to parse.  However, Python 
identifiers share a huge raft of properties with identifiers from many 
other languages, so this is a 'good enough' effort for now.  We deal 
explicitly with dashes because that is the most likely departure: Lisps 
commonly use dashes to separate method names, so protocols initially 
implemented in a lisp amp dialect may use dashes in argument or command 
names.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">key</td><td>a str, looking something like 'foo-bar-baz' or 'from'
</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a str which is a valid python identifier, looking something like 
'foo_bar_baz' or 'From'.
</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.amp._stringsToObjects">
    
  </a>
  <a name="_stringsToObjects">
    
  </a>
  <div class="functionHeader">
    
    def
    _stringsToObjects(strings, arglist, proto):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.0.0/twisted/protocols/amp.py#L2373" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Convert an AmpBox to a dictionary of python objects, converting through 
a given arglist.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">strings</td><td>an AmpBox (or dict of strings)
</td></tr><tr><td></td><td class="fieldArg">arglist</td><td>a list of 2-tuples of strings and Argument objects, as described in 
<code>Command.arguments</code>.
</td></tr><tr><td></td><td class="fieldArg">proto</td><td>an <a href="twisted.protocols.amp.AMP.html"><code>AMP</code></a> instance.
</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the converted dictionary mapping names to argument objects.
</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="twisted.protocols.amp._objectsToStrings">
    
  </a>
  <a name="_objectsToStrings">
    
  </a>
  <div class="functionHeader">
    
    def
    _objectsToStrings(objects, arglist, strings, proto):
    <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-11.0.0/twisted/protocols/amp.py#L2395" class="functionSourceLink">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    <div>Convert a dictionary of python objects to an AmpBox, converting through 
a given arglist.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">objects</td><td>a dict mapping names to python objects
</td></tr><tr><td></td><td class="fieldArg">arglist</td><td>a list of 2-tuples of strings and Argument objects, as described in 
<code>Command.arguments</code>.
</td></tr><tr><td></td><td class="fieldArg">strings</td><td>[OUT PARAMETER] An object providing the <a 
href="twisted.protocols.dict.html"><code>dict</code></a> interface which 
will be populated with serialized data.
</td></tr><tr><td></td><td class="fieldArg">proto</td><td>an <a href="twisted.protocols.amp.AMP.html"><code>AMP</code></a> instance.
</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The converted dictionary mapping names to encoded argument strings 
(identical to <code>strings</code>).
</td></tr></table></div>
  </div>
</div>
    <address>
      <a href="index.html">API Documentation</a> for <a href="http://twistedmatrix.com/">Twisted</a>, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2011-04-03 00:32:03.
    </address>
  </body>
</html>