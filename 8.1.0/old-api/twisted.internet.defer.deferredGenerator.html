<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>API docs for &ldquo;twisted.internet.defer.deferredGenerator&rdquo;</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="function">Function t.i.d.deferredGenerator(f):</h1>
    <p>
      <span id="part">Part of <a href="twisted.html">twisted</a>.<a href="twisted.internet.html">internet</a>.<a href="twisted.internet.defer.html">defer</a></span>
      <a href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.1.0/twisted/internet/defer.py#L629">View Source</a>
      
    </p>
    <div>
      
    </div>
    <div><p>Maintainer: <a href="mailto:radix&#64;twistedmatrix.com">Christopher 
Armstrong</a></p>
<p>deferredGenerator and waitForDeferred help you write Deferred-using 
code that looks like a regular sequential function. If your code has a 
minimum requirement of Python 2.5, consider the use of <a 
href="twisted.internet.defer.html#inlineCallbacks"><code>inlineCallbacks</code></a> 
instead, which can accomplish the same thing in a more concise 
manner.</p>
There are two important functions involved: waitForDeferred, and 
deferredGenerator. They are used together, like this:
<pre class="literalblock">
   def thingummy():
       thing = waitForDeferred(makeSomeRequestResultingInDeferred())
       yield thing
       thing = thing.getResult()
       print thing #the result! hoorj!
   thingummy = deferredGenerator(thingummy)
</pre>
<p>waitForDeferred returns something that you should immediately yield; 
when your generator is resumed, calling thing.getResult() will either 
give you the result of the Deferred if it was a success, or raise an 
exception if it was a failure. Calling <code>getResult</code> is 
<b>absolutely mandatory</b>. If you do not call it, <i>your program will 
not work</i>.</p>
<p>deferredGenerator takes one of these waitForDeferred-using generator 
functions and converts it into a function that returns a Deferred. The 
result of the Deferred will be the last value that your generator yielded 
unless the last value is a waitForDeferred instance, in which case the 
result will be <code>None</code>. If the function raises an unhandled 
exception, the Deferred will errback instead. Remember that 'return 
result' won't work; use 'yield result; return' in place of that.</p>
<p>Note that not yielding anything from your generator will make the 
Deferred result in None. Yielding a Deferred from your generator is also 
an error condition; always yield waitForDeferred(d) instead.</p>
The Deferred returned from your deferred generator may also errback if 
your generator raised an exception. For example:
<pre class="literalblock">
   def thingummy():
       thing = waitForDeferred(makeSomeRequestResultingInDeferred())
       yield thing
       thing = thing.getResult()
       if thing == 'I love Twisted':
           # will become the result of the Deferred
           yield 'TWISTED IS GREAT!'
           return
       else:
           # will trigger an errback
           raise Exception('DESTROY ALL LIFE')
   thingummy = deferredGenerator(thingummy)
</pre>
Put succinctly, these functions connect deferred-using code with this 
'fake blocking' style in both directions: waitForDeferred converts from a 
Deferred to the 'blocking' style, and deferredGenerator converts from the 
'blocking' style to a Deferred.
<table class="fieldTable"></table></div>
    
    
    <div id="splitTables">
      
      
      
    </div>
    
    
    
    
    
    <address>
      <a href="index.html">API Documentation</a> for <a href="http://twistedmatrix.com/trac">Twisted</a>, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2008-05-18 16:50:21.
    </address>
  </body>
</html>